# Scheduling Model Review
### VLIW Equals (EQ) Scheduling Model
- Each operation takes exactly specified latency
- Efficient register usage (Effectively more registers)
- No need for register renaming or buffering
  - Bypass from function unit output to inputs
  - Register writes whenever functional unit completes
- Compiler depends on not having registers visible early

### VLIW Less-Than-or-Equals (LEQ) Scheduling Model
- Each operation may take less than or equal to its specified latency
  - Destination can be written any time after instruction issue
  - Dependent instruction still needs to be scheduled after instruction latency
- Precise interrupts simplified
- Binary compatibility preserved when latencies are reduced

# Review of Predication
### VLIW Instruction Encoding
If VLIW is very big, you will need to fill it with a lot of nops to do simple instructions.
- Schemes to reduce effect of unused fields
  - Compressed format in memory, expand on l-cache refill
    - Used in Multiflow Trace
    - introduces instruction addressing challenge
- Mark parallel groups (mark where bundle starts and stops)
- Provide a single-op VLIW instruction
### Predication
Problem: Mispredicted branches limit ILP (OOO superscalar can handle it better by dynamically scheduling around branch mispredicts)

Solution: Eliminate hard to predict branches with predicated execution

Predication helps with small branch regions and/or branches that are hard to predict by turning control flow into data flow. You execute both sides and then pick the correct one with select.

Most basic form of predication: conditional moves
- movz rd,rs,rt if (R[rt} == 0) then R[rd] <- R[rs]
- movn rd,rst,rt if (R[rt] != 0) then R[rd] <- R[rs]
  
C             non-predicated MIPS-like assembly            MIPS-like assembly with predication
![image](https://github.com/coolnikitav/coding-lessons/assets/30304422/1fa035d4-30b1-44db-afbb-2f4d75502a68)

What if the if and the else statement have 1000 instructions in each of them? Then we would not want to predicate because we dont want to execute 2000 instructions.
### Full Predication
- Almost all instructions can be executed conditionally under predicate
- Instruction becomes NOP if predicate register false
  
![image](https://github.com/coolnikitav/coding-lessons/assets/30304422/8b270a8b-9166-4225-a7a6-adc565a5a9f2)

If p1 == 1, executed instr 3. If it's 0, nullify it.

"(p1) instr3 || (p2) instr 5" means they are executing at the same time

# Predication Implementation
### Predicates and the Datapath
![image](https://github.com/coolnikitav/coding-lessons/assets/30304422/c47bc51b-d04d-4804-acc1-a65127b2324f)

 - If the condition is not true, suppress the writeback:

   ![image](https://github.com/coolnikitav/coding-lessons/assets/30304422/8b51df16-6ef6-4cba-8615-8da1a424bddb)
- Bypassing value doesn't work!
  - Need initial value (extra read port on RF)
 
### Problems with Full Predication
- Adds another register file
- Need to bypass predicates
- Need original value to use data value bypassing
