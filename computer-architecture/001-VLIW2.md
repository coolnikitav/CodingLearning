# Scheduling Model Review
### VLIW Equals (EQ) Scheduling Model
- Each operation takes exactly specified latency
- Efficient register usage (Effectively more registers)
- No need for register renaming or buffering
  - Bypass from function unit output to inputs
  - Register writes whenever functional unit completes
- Compiler depends on not having registers visible early

### VLIW Less-Than-or-Equals (LEQ) Scheduling Model
- Each operation may take less than or equal to its specified latency
  - Destination can be written any time after instruction issue
  - Dependent instruction still needs to be scheduled after instruction latency
- Precise interrupts simplified
- Binary compatibility preserved when latencies are reduced

# Review of Predication
### VLIW Instruction Encoding
If VLIW is very big, you will need to fill it with a lot of nops to do simple instructions.
- Schemes to reduce effect of unused fields
  - Compressed format in memory, expand on l-cache refill
    - Used in Multiflow Trace
    - introduces instruction addressing challenge
- Mark parallel groups (mark where bundle starts and stops)
- Provide a single-op VLIW instruction
### Predication
Problem: Mispredicted branches limit ILP (OOO superscalar can handle it better by dynamically scheduling around branch mispredicts)

Solution: Eliminate hard to predict branches with predicated execution

Predication helps with small branch regions and/or branches that are hard to predict by turning control flow into data flow.

Most basic form of predication: conditional moves
- movz rd,rs,rt if (R[rt} == 0) then R[rd] <- R[rs]
- movn rd,rst,rt if (R[rt] != 0) then R[rd] <- R[rs]
